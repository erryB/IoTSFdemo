using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using DeviceActor.Interfaces;
using CommonResources;
using AlarmServiceInterfaces;
using Microsoft.ServiceFabric.Actors.Runtime;
using Microsoft.ServiceFabric.Actors;
using Microsoft.ServiceFabric.Services.Remoting.Client;
using AlarmWriterService.Interfaces;
using Newtonsoft.Json;
using System.Text;

namespace DeviceActor
{
    /// <remarks>
    /// This class represents an actor.
    /// Every ActorID maps to an instance of this class- n.
    /// The StatePersistence attribute determines persistence and replication of actor state:
    ///  - Persisted: State is written to disk and replicated.
    ///  - Volatile: State is kept in memory only and replicated.
    ///  - None: State is kept in memory only and not replicated.
    /// </remarks>
    [StatePersistence(StatePersistence.Persisted)]
    internal class DeviceActor : Actor, IDeviceActor
    {
        
        
        /// <summary>
        /// Initializes a new instance of DeviceActor
        /// </summary>
        /// <param name="actorService">The Microsoft.ServiceFabric.Actors.Runtime.ActorService that will host this actor instance.</param>
        /// <param name="actorId">The Microsoft.ServiceFabric.Actors.ActorId for this actor instance.</param>
        public DeviceActor(ActorService actorService, ActorId actorId)
            : base(actorService, actorId)
        {
        }

        public async Task UpdateDeviceStateAsync(DeviceMessage currentDeviceMessage, CancellationToken cancellationToken)
        {
            Object alarmMsg = null;

            //string deviceID = currentDeviceMessage.DeviceID;
            if (currentDeviceMessage.MessageType == MessagePropertyName.TempHumType)
            {
                //ALARM if Temperature > 30 and Temperature is increasing and Humidity > 20
                var previousTemperature = await this.StateManager.GetStateAsync<double>(MessagePropertyName.Temperature);
                var currentTemperature = Double.Parse(currentDeviceMessage.MessageData[MessagePropertyName.Temperature]);
                var currentHumidity = Double.Parse(currentDeviceMessage.MessageData[MessagePropertyName.Humidity]);

                if (currentTemperature > AlarmParameters.TempThreshold && currentTemperature > previousTemperature && currentHumidity > AlarmParameters.HumThreshold)
                {
                    alarmMsg = new
                    {
                        DeviceID = currentDeviceMessage.DeviceID,
                        MessageID = currentDeviceMessage.MessageID,
                        AlarmMessage = $"Too high temperature and humidity! Temperature: {currentDeviceMessage.MessageData[MessagePropertyName.Temperature]}, Humidity: {currentDeviceMessage.MessageData[MessagePropertyName.Humidity]}",
                        Timestamp = DateTime.Now
                    };

                    //alarmMsg = $"ALARM generated by {currentDeviceMessage.DeviceID}, MessageID {currentDeviceMessage.MessageID}: too high temperature and humidity! Temperature: {currentDeviceMessage.MessageData[MessagePropertyName.Temperature]}, Humidity: {currentDeviceMessage.MessageData[MessagePropertyName.Humidity]}";
                }

                //update Actor states
                await this.StateManager.AddOrUpdateStateAsync<double>(MessagePropertyName.Temperature, currentTemperature, (x, y) => currentTemperature);
                await this.StateManager.AddOrUpdateStateAsync<double>(MessagePropertyName.Humidity, currentHumidity, (x, y) => currentHumidity);

            }
            else if (currentDeviceMessage.MessageType == MessagePropertyName.TempOpenDoorType)
            {
                var previousOpenCount = await this.StateManager.GetStateAsync<int>(MessagePropertyName.OpenDoorCounter);
                int currentOpenDoorCount;
                var currentTemperature = Double.Parse(currentDeviceMessage.MessageData[MessagePropertyName.Temperature]);

                if (currentDeviceMessage.MessageData[MessagePropertyName.OpenDoor] == "True")
                {
                    currentOpenDoorCount = previousOpenCount + 1;
                }
                else
                {
                    currentOpenDoorCount = 0;
                }
                if (Double.Parse(currentDeviceMessage.MessageData[MessagePropertyName.Temperature]) > AlarmParameters.TempThreshold && currentOpenDoorCount > AlarmParameters.OpenDoorToGenerateAlarm)
                {

                    alarmMsg = new
                    {
                        DeviceID = currentDeviceMessage.DeviceID,
                        MessageID = currentDeviceMessage.MessageID,
                        AlarmMessage = $"The door is still open and the temperature is {currentDeviceMessage.MessageData[MessagePropertyName.Temperature]}. PLEASE CLOSE THE DOOR!",
                        Timestamp = DateTime.Now
                    };

                    //alarmMsg = $"ALARM generated by {currentDeviceMessage.DeviceID}, MessageID {currentDeviceMessage.MessageID}: The door is still open and the temperature is {currentDeviceMessage.MessageData[MessagePropertyName.Temperature]}. CLOSE THE DOOR.";


                    //update Actor State
                    await this.StateManager.AddOrUpdateStateAsync<double>(MessagePropertyName.Temperature, currentTemperature, (x, y) => currentTemperature);
                    await this.StateManager.AddOrUpdateStateAsync<int>(MessagePropertyName.OpenDoorCounter, currentOpenDoorCount, (x, y) => currentOpenDoorCount);
                }
            }
            else if (currentDeviceMessage.MessageType == MessagePropertyName.UnknownType)
            {
                alarmMsg = new
                {
                    DeviceID = "unknown",
                    MessageID = "unknown", 
                    AlarmMessage = "ALARM! Unknown device",
                    Timestamp = DateTime.Now
                };
            }

            //var proxyAlarmWriter = ServiceProxy.Create<IAlarmService>(new Uri("fabric:/EBIoTApplication/AlarmService"));
            //await proxyAlarmWriter.ReceiveAlarmAsync(alarmMsg, deviceID);

            var messageString = JsonConvert.SerializeObject(alarmMsg);
            
            var proxyAlarmWriter = ServiceProxy.Create<IAlarmWriterService>(new Uri("fabric:/EBIoTApplication/AlarmWriterService"));
            await proxyAlarmWriter.SendAlarmAsync(messageString, cancellationToken);

        }






        //    if ( deviceID == "Batman")
        //    {
        //        BatmanState prevBatmanState = (BatmanState)StateManager.GetStateAsync<BatmanState>(deviceID).AsyncState;
        //        var currentBatmanState = new BatmanState();

        //        Batman batmanDevice = (Batman)currentDeviceMessage;
        //        currentBatmanState.CurrentTemperature = batmanDevice.Temperature;
        //        currentBatmanState.CurrentHumidity = batmanDevice.Humidity;
        //        if (currentBatmanState.CurrentTemperature > tempThreshold)
        //        {
        //            currentBatmanState.IncreasingTemperatureCount = prevBatmanState.IncreasingTemperatureCount;
        //        }
        //        if (currentBatmanState.CurrentHumidity > humThreshold)
        //        {
        //            currentBatmanState.IncreasingHumidityCount = prevBatmanState.IncreasingHumidityCount + 1;
        //        }
        //        if (currentBatmanState.IncreasingTemperatureCount > HighTempToGenerateAlarm)
        //        {
        //            alarmMsg = "ALARM generated by Batman, high temperature! Message ID: " + batmanDevice.MessageID + " timestamp: " + batmanDevice.Timestamp;
        //        }

        //        await StateManager.AddStateAsync<BatmanState>(deviceID, currentBatmanState);

        //    }
        //    else if (deviceID == "Joker")
        //    {
        //        JokerState prevJokerState = (JokerState)StateManager.GetStateAsync<JokerState>(deviceID).AsyncState;

        //        var currentJokerState = new JokerState();
        //        Joker jokerDevice = (Joker)currentDeviceMessage;
        //        currentJokerState.CurrentTemperature = jokerDevice.Temperature;
        //        currentJokerState.CurrentlyOpen = jokerDevice.OpenDoor;
        //        if (currentJokerState.CurrentTemperature > tempThreshold)
        //        {
        //            currentJokerState.IncreasingTemperatureCount = prevJokerState.IncreasingTemperatureCount + 1;
        //        }
        //        if (currentJokerState.CurrentlyOpen)
        //        {
        //            currentJokerState.OpenDoorCount = prevJokerState.OpenDoorCount + 1;
        //        }
        //        if (currentJokerState.IncreasingTemperatureCount > HighTempToGenerateAlarm && currentJokerState.OpenDoorCount > OpenDoorToGenerateAlarm)
        //        {
        //            alarmMsg = "ALARM generated by Joker, open door with high temperature! Message ID: " + jokerDevice.MessageID + " timestamp: " + jokerDevice.Timestamp;
        //        }

        //        await StateManager.AddStateAsync<JokerState>(deviceID, currentJokerState);


        //    }
        //    else
        //    {
        //        alarmMsg = "ALARM! Device not recognized";
        //    }

        //    var proxyAlarmWriter = ServiceProxy.Create<IAlarmService>(new Uri("fabric:/EBIoTApplication/AlarmService"));
        //    await proxyAlarmWriter.ReceiveAlarmAsync(alarmMsg, deviceID);

        //}

        /// <summary>
        /// This method is called whenever an actor is activated.
        /// An actor is activated the first time any of its methods are invoked.
        /// </summary>
        protected override Task OnActivateAsync()
        {
            ActorEventSource.Current.ActorMessage(this, "Actor activated.");

            // The StateManager is this actor's private state store.
            // Data stored in the StateManager will be replicated for high-availability for actors that use volatile or persisted state storage.
            // Any serializable object can be saved in the StateManager.
            // For more information, see https://aka.ms/servicefabricactorsstateserialization

            return this.StateManager.TryAddStateAsync("count", 0);
        }

        ///// <summary>
        ///// TODO: Replace with your own actor method.
        ///// </summary>
        ///// <returns></returns>
        //Task<int> IDeviceActor.GetCountAsync(CancellationToken cancellationToken)
        //{
        //    return this.StateManager.GetStateAsync<int>("count", cancellationToken);
        //}

        ///// <summary>
        ///// TODO: Replace with your own actor method.
        ///// </summary>
        ///// <param name="count"></param>
        ///// <returns></returns>
        //Task IDeviceActor.SetCountAsync(int count, CancellationToken cancellationToken)
        //{
        //    // Requests are not guaranteed to be processed in order nor at most once.
        //    // The update function here verifies that the incoming count is greater than the current count to preserve order.
        //    return this.StateManager.AddOrUpdateStateAsync("count", count, (key, value) => count > value ? count : value, cancellationToken);
        //}
    }
}
